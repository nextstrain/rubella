#!/usr/bin/env python3
"""
Expects the NDJSON records (on STDIN) to have the GenBank data under the 'entrez'
key. Write out the records on STDOUT with an additional 'genotype_metadata' key.
"""

from augur.io.json import load_ndjson
import json
from collections.abc import Generator
from collections import defaultdict
import re
from pprint import pp
from sys import stderr, stdin, stdout

def clean_up_genotype(genotype: str) -> str|None:
    if genotype.startswith("RV"):
        genotype = genotype[2:]
    if genotype.endswith(';'):
        genotype = genotype[:-1]

    # coerce to uppercase -- NOTE: John A mentioned there is semantic meaning
    # in case here. TODO XXX
    genotype = genotype.upper()

    # Some strain names encode "CRS" in what we interpret to be the genotype...
    if genotype=='CRS':
        return None
    if genotype=='UNKNOWN' or genotype=='GENOTYPE':
        return None

    return genotype


def extract_genotype(s: str) -> str|None:
    # genotype is often explicitly noted
    if groups:=re.search("[Gg]enotype:? (\S+)", s):
        return clean_up_genotype(groups[1])
    # look for genotype encoded in strain name. Strain names examples:
    # RVs/Osaka.JPN/33.12[1E]
    # RVs/Shizuoka.JPN/13.15/[1E]
    # RVs/Osaka.JPN/39.13/[2B](CRS)
    # RVi/Tokyo.JPN18.13[2B]
    # RVi/Taipei.TWN/08.09/2
    if groups:=re.search("(\S+/\S+(/\S+){0,2})", s):
        strain_name = groups[1]
        if g:=re.search(".*\[(\S+)\]", strain_name):
            return clean_up_genotype(g[1])

    return None


def source_feature(record: dict):
    return next((f for f in record['features'] if f['type']=='source'), {})


def as_list(x: str|list[str]) -> list[str]:
    return x if isinstance(x, list) else [x]


def potential_fields(record: dict) -> Generator[str, None, None]:
    """
    Yields strings which may contain genotype information
    """
    yield from as_list(record['record'].get('isolate', []))
    yield from as_list(record['record'].get('note', []))
    yield from as_list(record['record'].get('organism', []))
    yield from as_list(record['record'].get('strain', []))
    # Not considering source_feature(record).get("annotations", "").get("isolate", "")
    # as (it seems) it's the same as record.isolate
    yield record['record'].get('source', "")
    yield source_feature(record).get("strain", "")
    yield source_feature(record).get("title", "")


if __name__=="__main__":
    counts = {'records': 0, 'match': 0, 'observed_genotypes': defaultdict(int)}
    for record in load_ndjson(stdin):
        genbank = record['entrez']
        accession = record['accession']
        counts["records"]+=1
        genotype = ""
        for field in potential_fields(genbank):
            if genotype:=extract_genotype(field):
                counts['match']+=1
                counts['observed_genotypes'][genotype]+=1
                break
        record['genotype_metadata'] = genotype
        print(json.dumps(record), end="\n", file=stdout)
    pp(counts, stream=stderr)
